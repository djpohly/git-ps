#!/bin/bash -e

cmd_dash=$(basename -- "$0")
cmd=${cmd_dash/git-/git }
subcommand=$1
# Don't exit if no subcommand is given
shift || true

branch=

###### SETUP ######
#
# One branch can have multiple ps branches associated with it
#   main-ps, main|ps, ps/main, main#ps, main!ps, main.ps
# ps branch will have a reference to its upstream, but it could also have a
# "real" upstream on an actual remote (for sharing the patch stack), so
# patchstack-upstream should be a separate config option temporarily applied
# during the git-ps command.
# A patch stack's upstream branch can move without updating the patch stack
# itself (e.g. a commit/pull/merge on the upstream branch).  The patch stack
# should be tracked relative to a *base commit* until it is rebased on its
# *upstream branch*.
#
# Possible states:
#   - No patch stack is active.  On a normal branch.
#   - Named patch stack is active.
#   - Detached patch stack is active.  Normal detached HEAD warnings should be
#     shown when committing.  This stack can be GC'd once abandoned.  No
#     branch configuration is available, so use refs to keep track of the
#     state, and remove them when switching to another stack.
#
# Notes:
#   - use git-cherry when updating from upstream


usage() {
	cat <<- EOF
		usage: $cmd init [<name>]
		   or: $cmd rm [-f] <name>
		   or: $cmd list [-a]
		   or: $cmd log
		   or: $cmd show (<id-or-range> [<id-or-range>...]
		   or: $cmd rebase
		   or: $cmd pull
		   or: $cmd isolate <id-or-range> [<id-or-range>...]

		id-or-range can be a patch number such as 2 or a range like 1-4.
	EOF
}

bug() {
	printf >&2 '%s: ' "$cmd_dash"
	printf >&2 "$@"
	printf >&2 '\nBUG! This is not supposed to happen.\n'
	exit 1
}

die() {
	printf >&2 '%s: ' "$cmd_dash"
	printf >&2 "$@"
	printf >&2 '\n'
	exit 1
}

get_branch() {
	branch=$(git branch --show-current 2>/dev/null)
}

require_non_ps_branch() {
	get_branch
	if [ -z "$branch" ]; then
		die "\`%s %s' requires a branch to be checked out" "$cmd" "$subcommand"
	fi
	if git symbolic-ref -q "refs/ps/$branch/upstream" >/dev/null; then
		die "branch \`%s' is already a patch stack" "$branch"
	fi
	if git rev-parse --verify -q "refs/ps/$branch/base^{commit}" >/dev/null; then
		die "branch \`%s' is already a patch stack" "$branch"
	fi
}

require_ps() {
	get_branch

	# It is possible to `git switch' from a detached patch stack to a
	# regular branch, leaving the GIT_PS_* refs in place.
	if [ -z "$branch" ]; then
		# Detached HEAD, should be on a detached patch stack if
		# anything.
		upstream="$(git symbolic-ref -q GIT_PS_UPSTREAM)"
		return
	fi

	# Not in detached HEAD state, so there should be no detached
	# patch stack active.  Remove the temporary refs if they
	# exist.
	git symbolic-ref -d GIT_PS_UPSTREAM 2>/dev/null || true
	git update-ref -d GIT_PS_BASE 2>/dev/null || true

	# Get upstream and base from git config
	if ! upstream="$(git symbolic-ref -q "refs/ps/$branch/upstream")"; then
		die "could not get upstream for branch \`%s' (not a patch stack?)" "$branch"
	fi
	if ! base="$(git rev-parse --verify -q "refs/ps/$branch/base^{commit}" 2>/dev/null)"; then
		die "could not get base for branch \`%s' (not a patch stack?)" "$branch"
	fi

	# Sanity checks
	if ! git merge-base --is-ancestor "$base" "$branch"; then
		die "patch stack base is incorrect (consider running \`%s rebase')" "$cmd"
	fi
	if ! git merge-base --is-ancestor "$base" "$upstream"; then
		die "patch stack base is not in upstream (consider running \`%s rebase')" "$cmd"
	fi
	if [ "$(git rev-list --count --min-parents=2 "$base".."$branch")" -ne 0 ]; then
		die "patch stack is not linear (consider running \`%s rebase')" "$cmd"
	fi
}

parse_patchnums() {
	local -a shas
	mapfile -t shas < <(git rev-list --right-only "${upstream}...${branch}")
	for num; do
		case $num in
			*-*)
				start=${num%%-*}
				stop=${num#*-}
				for subnum in $(seq -- "$start" "$stop"); do
					echo "${shas[$subnum]}"
				done
				;;
			*)
				echo "${shas[$num]}"
				;;
		esac
	done
}

git_ps_init() {
	require_non_ps_branch

	upstream=$branch
	branch="$upstream%${1:-ps}"

	# Create new branch and record the upstream and base
	git switch -c "$branch"
	git symbolic-ref "refs/ps/$branch/upstream" "$upstream"
	git update-ref "refs/ps/$branch/base" "$upstream" ''

	#git config "branch.$branch.rebase" true
}

git_ps_rm() {
	die "\`%s' not yet implemented" "$subcommand"
}

git_ps_list() {
	get_branch

	# Lists all patch stacks
	git for-each-ref --format='%(refname)' "refs/ps/*/upstream" | sed -e 's,^refs/ps/\(.*\)/upstream$,\1,'
}

git_ps_log() {
	require_ps

	# config=(
	# 	-c "branch.$branch.remote=."
	# 	-c "branch.$branch.merge=$upstream"
	# )
	# git "${config[@]}" status

	read behind cherry < <(git rev-list --cherry-mark --left-only --count "${upstream}...${branch}")
	printf 'Patches'
	if [ "$behind" -gt 0 ]; then
		if [ "$cherry" -gt 0 ]; then
			printf ' (%d commits behind upstream, %d already integrated)' "$behind" "$cherry"
		else
			printf ' (%d commits behind upstream)' "$behind"
		fi
	elif [ "$cherry" -gt 0 ]; then
		printf ' (%d already integrated)' "$cherry"
	fi
	printf ':\n'

	declare -A status=()
	declare -i n=0
	while read sha parent merge; do
		sigil=${sha::1}
		sha=${sha:1}
		case $sigil in
			+)
				git show -s --pretty=format:"%Cblue$(printf '%3d' "$n")%C(auto). %h %s" "$sha"
				;;
			=)
				git show -s --pretty=format:"%Cblue$(printf '%3d' "$n")%Creset. [2;9m%h %s%Creset" "$sha"
				;;
			*)
				bug 'unexpected format from git rev-list'
				;;
		esac
		let n+=1
	done < <(git rev-list --cherry-mark --right-only "${upstream}...${branch}")
	if [ "$(git rev-list --count --merges "${upstream}..${branch}")" -ne 0 ]; then
		printf 'warning: patch stack contains merge commits, rebase to fix\n' "$cmd"
	fi
}

git_ps_show() {
	require_ps

	git show $(parse_patchnums "$@")
}

git_ps_rebase() {
	die "\`%s' not yet implemented" "$subcommand"

	require_ps

	# TODO: attempt some kind of rebase to linearize patches?  maybe this
	# is just `git ps rebase'.

	# -c 'advice.skippedCherryPicks=false'
}

git_ps_pull() {
	die "\`%s' not yet implemented" "$subcommand"

	require_ps
}

git_ps_isolate() {
	die "\`%s' not yet implemented" "$subcommand"

	# It's ok if the current patch stack is detached; we can isolate a
	# subset of those.
	require_ps
}


# Commands that don't require a git environment
case $subcommand in
	-h)
		usage
		exit 0
		;;
esac

# Require a git directory and worktree
if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != true ]; then
	die "cannot be used without a working tree"
fi

case $subcommand in
	'') usage >&2;;
	help|-h) exec git help ps;;
	init|rm|list|log|show|rebase|pull|isolate)
		"git_ps_$subcommand" "$@"
		;;
	*)
		die "unknown subcommand: \`$subcommand'"
		;;
esac
