#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

cmd_dash=$(basename -- "$0")
cmd=${cmd_dash/git-/git }
subcommand=${1:-}
# Don't exit if no subcommand is given
shift || true

branch=

###### SETUP ######
#
# One branch can have multiple ps branches associated with it
#   main-ps, main|ps, ps/main, main#ps, main!ps, main.ps
# ps branch will have a reference to its upstream, but it could also have a
# "real" upstream on an actual remote (for sharing the patch stack), so
# patchstack-upstream should be a separate config option temporarily applied
# during the git-ps command.
# A patch stack's upstream branch can move without updating the patch stack
# itself (e.g. a commit/pull/merge on the upstream branch).  The patch stack
# should be tracked relative to a *base commit* until it is rebased on its
# *upstream branch*.
#
# Possible states:
#   - No patch stack is active.  On a normal branch.
#   - Named patch stack is active.
#   - Detached patch stack is active.  Normal detached HEAD warnings should be
#     shown when committing.  This stack can be GC'd once abandoned.  No
#     branch configuration is available, so use refs to keep track of the
#     state, and remove them when switching to another stack.
#
# Notes:
#   - use git-cherry when updating from upstream


usage() {
	cat <<- EOF
		usage: $cmd new [<name>]
		   or: $cmd checkout [<name>]
		   or: $cmd delete [-f]
		   or: $cmd list
		   or: $cmd log
		   or: $cmd show <id-or-range> [<id-or-range>...]
		   or: $cmd todo <description>
		   or: $cmd isolate <id-or-range> [<id-or-range>...]
		   or: $cmd integrate
		   or: $cmd pick <id>
		   or: $cmd rebase [-i] [<branch>]
		   or: $cmd pull

		<id-or-range> can be a patch number such as 2 or a range like 1-4.
	EOF
}

bug() {
	printf >&2 '%s: ' "$cmd_dash"
	printf >&2 "$@"
	printf >&2 '\nBUG! This is not supposed to happen.\n'
	exit 1
}

die() {
	local usage=
	if [ "$1" = "-u" ]; then
		usage=y
		shift
	fi
	printf >&2 '%s: ' "$cmd_dash"
	printf >&2 "$@"
	printf >&2 '\n'
	if [ -n "$usage" ]; then
		usage >&2
	fi
	exit 1
}

get_branch() {
	branch=$(git branch --show-current 2>/dev/null)

	if [ -z "$branch" ]; then
		# Detached
		branch=HEAD
		upstream_ref=refs/ps/DETACHED_UPSTREAM
		base_ref=refs/ps/DETACHED_BASE
	else
		upstream_ref="refs/$branch/upstream"
		base_ref="refs/$branch/base"
	fi
}

require_non_ps_branch() {
	get_branch
	if [ "$branch" = HEAD ]; then
		die "\`%s %s' requires a branch to be checked out" "$cmd" "$subcommand"
	fi
	case $branch in
		ps/*) die "branch \`%s' is already a patch stack" "$branch";;
	esac
	if git symbolic-ref -q "refs/$branch/upstream" >/dev/null; then
		die "branch \`%s' is already a patch stack" "$branch"
	fi
	if git rev-parse --verify -q "refs/$branch/base^{commit}" >/dev/null; then
		die "branch \`%s' is already a patch stack" "$branch"
	fi
}

require_ps() {
	get_branch

	if [ "$branch" != HEAD ]; then
		# Ensure the checked out branch is in the refs/heads/ps namespace
		case $branch in
			ps/*) ;;
			*) die "current branch \`%s' is not a patch stack" "$branch";;
		esac

		# It is possible to `git switch' from a detached patch stack to a regular
		# branch, leaving the refs/ps/DETACHED_* refs in
		# place.  We're not in detached HEAD state now, so
		# remove the temporary refs if they're still
		# around.
		git symbolic-ref -d refs/ps/DETACHED_UPSTREAM 2>/dev/null || true
		git update-ref -d refs/ps/DETACHED_BASE 2>/dev/null || true
	fi

	# Read upstream and base refs
	if ! upstream="$(git symbolic-ref -q "$upstream_ref")"; then
		die "could not get upstream (not a patch stack?)"
	fi
	if ! base="$(git rev-parse --verify -q "${base_ref}^{commit}" 2>/dev/null)"; then
		die "could not get base (not a patch stack?)"
	fi

	# Sanity checks
	if ! git merge-base --is-ancestor "$base" "$branch"; then
		die "patch stack base is incorrect (consider running \`%s rebase')" "$cmd"
	fi
	if ! git merge-base --is-ancestor "$base" "$upstream"; then
		die "patch stack base is not in upstream (consider running \`%s rebase')" "$cmd"
	fi
	if [ "$(git rev-list --count --min-parents=2 "$base".."$branch")" -ne 0 ]; then
		die "patch stack is not linear (consider running \`%s rebase')" "$cmd"
	fi
}

parse_patchnums() {
	local -a shas
	mapfile -t shas < <(git rev-list --right-only "${upstream}...${branch}")
	for num; do
		case $num in
			*-*)
				start=${num%%-*}
				stop=${num#*-}
				for subnum in $(seq -- "$start" "$stop"); do
					echo "${shas[$subnum]}"
				done
				;;
			*)
				echo "${shas[$num]}"
				;;
		esac
	done
}

git_ps_new() {
	# Need to be on a non-ps branch to use as upstream (for now, maybe upstream
	# can be specified later)
	require_non_ps_branch

	upstream=$branch
	branch="ps/${1:-$upstream}"

	# Create new branch and record the upstream and base
	git switch -c "$branch"
	git symbolic-ref "refs/$branch/upstream" "$upstream"
	git update-ref "refs/$branch/base" "$upstream" ''

	#git config "branch.$branch.rebase" true
}

git_ps_checkout() {
	if [ $# -lt 1 ]; then
		require_non_ps_branch
	else
		branch=$1
	fi
	if ! git checkout "ps/$branch" -- 2>/dev/null; then
		die "no patch stack named \`%s'" "$branch"
	fi
}

git_ps_delete() {
	require_ps
	if [ "$branch" = HEAD ]; then
		# Detached patch stack
		die "detached patch stack does not need to be deleted explicitly"
	fi

	local force=
	case $1 in
		-f)
			force=y
			shift
			;;
	esac

	# check to see if fully integrated?
	if [ -z "$force" -a "$(git rev-list --count --cherry-pick --right-only "${upstream}...${branch}")" -ne 0 ]; then
		die "patch stack \`%s' is not fully integrated (use -f to delete anyway)" "$branch"
	fi

	git switch "${upstream#refs/heads/}"
	if [ "$branch" != HEAD ]; then
		git branch -D "$branch"
	fi
	git symbolic-ref -d "$upstream_ref"
	git update-ref -d "$base_ref"
}

git_ps_list() {
	# Lists all patch stacks
	git branch --list 'ps/*'
}

git_ps_log() {
	require_ps

	# config=(
	# 	-c "branch.$branch.remote=."
	# 	-c "branch.$branch.merge=$upstream"
	# )
	# git "${config[@]}" status

	read behind cherry < <(git rev-list --cherry-mark --left-only --count "${upstream}...${branch}")
	printf 'Patches'
	if [ "$behind" -gt 0 ]; then
		if [ "$cherry" -gt 0 ]; then
			printf ' (%d commits behind upstream, %d already integrated)' "$behind" "$cherry"
		else
			printf ' (%d commits behind upstream)' "$behind"
		fi
	elif [ "$cherry" -gt 0 ]; then
		printf ' (%d already integrated)' "$cherry"
	fi
	printf ':\n'

	declare -A status=()
	declare -i n=0
	while read sha parent merge; do
		sigil=${sha::1}
		sha=${sha:1}
		case $sigil in
			+)
				git -P rev-list --no-walk --no-commit-header --pretty=format:"%Cblue$(printf '%3d' "$n")%C(auto)  %h  %<|(-1,trunc)%s" "$sha"
				;;
			=)
				git -P rev-list --no-walk --no-commit-header --pretty=format:"%Cblue$(printf '%3d' "$n")%Creset  [2;9m%h%Creset  %<|(-1,trunc)%s" "$sha"
				;;
			*)
				bug 'unexpected format from git rev-list'
				;;
		esac
		let n+=1
	done < <(git rev-list --cherry-mark --right-only "${upstream}...${branch}")
	if [ "$(git rev-list --count --merges "${upstream}..${branch}")" -ne 0 ]; then
		printf 'warning: patch stack contains merge commits, rebase to fix\n' "$cmd"
	fi
}

git_ps_show() {
	require_ps

	if [ $# -eq 0 ]; then
		die -u "\`%s' requires an argument" "$subcommand"
	fi
	git show $(parse_patchnums "$@")
}

git_ps_todo() {
	require_ps

	git commit --allow-empty --only -m "$*"
}

detach_stack() {
	git checkout -q --detach
	git symbolic-ref refs/ps/DETACHED_UPSTREAM "$upstream"
	git update-ref refs/ps/DETACHED_BASE "$base"

	# Refresh variables
	get_branch
}

# Takes a list of commit SHAs on standard input
reorder_stack() {
	sed 's/^/pick /' |
	GIT_SEQUENCE_EDITOR='cat >' \
	git -c 'advice.skippedCherryPicks=false' rebase -i \
		--empty=keep --keep-empty --no-rebase-merges \
		--committer-date-is-author-date \
		--keep-base "$base"
}

git_ps_isolate() {
	# It's ok if the current patch stack is detached; we can isolate a
	# subset of those.
	require_ps

	detach_stack
	parse_patchnums "$@" | reorder_stack
}

git_ps_integrate() {
	die "\`%s' not yet implemented" "$subcommand"

	require_ps

	# merge to upstream ref, update base
	# can we squash, or will this not be detected by the original stack?
}

git_ps_pick() {
	require_ps

	if [ -z "${1-}" ]; then
		die -u "\`%s' requires a patch id" "$subcommand"
	fi

	if [ "$1" = 0 ]; then
		# Patch 0 is already at the top of the stack
		return
	fi

	sha=$(parse_patchnums "$1")

	{
		git rev-list --reverse "$base".."$branch" | grep -Fxv "$sha"
		echo "$sha"
	} | reorder_stack
}

git_ps_rebase() {
	require_ps

	local interactive=
	case ${1-} in
		-i)
			interactive=-i
			shift
			;;
	esac

	# Keep patches which are empty (i.e. to-do) but not those
	# which are newly empty because of the rebase.
	git -c 'advice.skippedCherryPicks=false' rebase \
		--empty=drop --keep-empty --no-rebase-merges \
		$interactive \
		--onto "${1:-$upstream}" "$base"

	if [ -n "${1-}" ]; then
		# Need to update upstream
		upstream=$1
		git symbolic-ref "$upstream_ref" "$upstream"
		git update-ref "$base_ref" "$upstream" "$base"
		base=$upstream
	fi

	# offer to remove patch stack if now fully merged
}

git_ps_pull() {
	require_ps

	remote="$(git config --local --get --default=origin "branch.$upstream.remote")"
	remoteref="$(git config --local --get --default="$upstream" "branch.$upstream.merge")"

	git fetch "$remote" "$remoteref:$upstream"
	git_ps_rebase
}


# Commands that don't require a git environment
case $subcommand in
	-h)
		usage
		exit 0
		;;
esac

# Require a git directory and worktree
if [ "$(git rev-parse --is-inside-work-tree 2>/dev/null)" != true ]; then
	die "cannot be used without a working tree"
fi

case $subcommand in
	'') usage >&2;;
	help|-h) exec git help ps;;
	new|checkout|delete|list|log|show|todo|integrate|pick|rebase|pull|isolate)
		"git_ps_$subcommand" "$@"
		;;
	*)
		die -u "unknown subcommand: \`$subcommand'"
		;;
esac
